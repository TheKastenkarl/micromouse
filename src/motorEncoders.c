
#include <xc.h>
#include "motorEncoders.h"

long g_rotationCounts[] = {0, 0}; // full rotation counts
long g_counts[] = {0, 0}; // absolute position
int g_deltaCountsSinceLastCall[] = {0, 0}; // velocity 

#include <math.h>

//****************************************************************INITIALISE QEI************************

void initQEI1(unsigned int startPos) {
    QEI1CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI1CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI1CONbits.SWPAB = 0; // Phase A and B not swapped
    QEI1CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI1CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI1CONbits.POSRES = 0; // index does not reset position counter
    QEI1CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI1CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX1CNT = 0xffff;
    POS1CNT = startPos;
    g_rotationCounts[0] = 0;

    IFS3bits.QEI1IF = 0; // clear interrupt flag
    IEC3bits.QEI1IE = 1; // enable interrupt
    IPC14bits.QEI1IP = 5;
}

void initQEI2(unsigned int startPos) {
    QEI2CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI2CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI2CONbits.SWPAB = 1; // Phase A and B  swapped
    QEI2CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI2CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI2CONbits.POSRES = 0; // index does not reset position counter
    QEI2CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI2CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX2CNT = 0xffff;
    POS2CNT = startPos;
    g_rotationCounts[1] = 0;

    IFS4bits.QEI2IF = 0; // clear interrupt flag
    IEC4bits.QEI2IE = 1; // enable interrupt
    IPC18bits.QEI2IP = 5;
}

void updateRotationCount(volatile uint16_t posCount, long* globalCount) {
    long change = 0x10000; // POS1CNT goes until 65535 = 0x1111;
    if (posCount < 32768) { // was a roll over
        *globalCount = *globalCount + change; // we had a positive roll-over
    } else { // was a roll under
        *globalCount = *globalCount - change; // we had a negative roll-over
    }
}

void __attribute__((__interrupt__, auto_psv)) _QEI1Interrupt(void) {
    // Interrupt generated by QEI roll over/under
    IFS3bits.QEI1IF = 0; // clear interrupt
    updateRotationCount(POS1CNT, &(g_rotationCounts[0]));
}

void __attribute__((__interrupt__, auto_psv)) _QEI2Interrupt(void) {
    // Interrupt generated by QEI roll over/under
    IFS4bits.QEI2IF = 0; // clear interrupt
    updateRotationCount(POS2CNT, &(g_rotationCounts[1]));
}

void updatePositionCount(unsigned char encoderNumber) {
    //disable interrupts to make sure we have consistent data
    _NSTDIS = 1;
    switch (encoderNumber) {
        case 1:
            GET_ENCODER_1(g_counts[encoderNumber]);
            break;

        case 2:
            GET_ENCODER_2(g_counts[encoderNumber]);
            break;
    }
    _NSTDIS = 0;
}

// Caution: requires absolute counts to be up to date
// Call directly before in order to achieve that
void updateDeltaCountsSinceLastCall(unsigned char encoderNumber) {
    static long oldPositions[] = {0, 0};
    long currentPosition;

    currentPosition = g_counts[encoderNumber];
    g_deltaCountsSinceLastCall[encoderNumber] = (currentPosition - oldPositions[encoderNumber]);
    oldPositions[encoderNumber] = currentPosition;
}

// TODO move to utils?
float convertCountsToRad(long counts) {
    return 3.141592 * 2 * counts / COUNTS_PER_WHEELROTATION;
}

// TODO move to utils?
float convertCountsToWheelRots(long counts) {
    return (float) counts / COUNTS_PER_WHEELROTATION;
}