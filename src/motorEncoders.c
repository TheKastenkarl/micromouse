#include <xc.h>
#include "motorEncoders.h"
#include <math.h>

// Motor Encoder Module:
//
// Module for reading the motor position and velocities.
// Function updateEncoderStates() is the main interface.
//
// Motor positions can be read from g_counts.
// Motor position velocities from g_deltaCountsSinceLastCall.

long g_counts[] = {0, 0}; // absolute position
int g_deltaCountsSinceLastCall[] = {0, 0}; // velocity
long g_rotationCounts[] = {0, 0}; // full rotation counts, helper variable

/**
 * Initialize the QEI1 encoder for the left motor.
 * @param startPos: Start position in raw counts. Usually 0.
 */
void initQEI1(unsigned int startPos) {
    QEI1CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI1CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI1CONbits.SWPAB = 0; // Phase A and B not swapped
    QEI1CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI1CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI1CONbits.POSRES = 0; // index does not reset position counter
    QEI1CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI1CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX1CNT = 0xffff;
    POS1CNT = startPos;
    g_rotationCounts[0] = 0;

    IFS3bits.QEI1IF = 0; // clear interrupt flag
    IEC3bits.QEI1IE = 1; // enable interrupt
    IPC14bits.QEI1IP = 5;
}

/**
 * Initialize the QEI2 encoder for the right motor.
 * @param startPos: Start position in raw counts. Usually 0.
 */
void initQEI2(unsigned int startPos) {
    QEI2CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI2CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI2CONbits.SWPAB = 1; // Phase A and B  swapped
    QEI2CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI2CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI2CONbits.POSRES = 0; // index does not reset position counter
    QEI2CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI2CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX2CNT = 0xffff;
    POS2CNT = startPos;
    g_rotationCounts[1] = 0;

    IFS4bits.QEI2IF = 0; // clear interrupt flag
    IEC4bits.QEI2IE = 1; // enable interrupt
    IPC18bits.QEI2IP = 5;
}

/**
 * Update the global full rotation count. Is called on QEI interrupts when there
 * either is an overflow or underflow of encoder counts.
 * 
 * @param posCount: Count value after the over-/underflow
 * @param globalCount Global count to add to. Only includes full rotations. 
 */
void updateRotationCount(volatile uint16_t posCount, long* globalCount) {
    long change = 0x10000; // POS1CNT goes until 65535 = 0x1111;
    if (posCount < 32768) { // was a roll over
        *globalCount = *globalCount + change; // we had a positive roll-over
    } else { // was a roll under
        *globalCount = *globalCount - change; // we had a negative roll-over
    }
}

/**
 * Interrupt generated by QEI roll over/under
 */
void __attribute__((__interrupt__, auto_psv)) _QEI1Interrupt(void) {
    IFS3bits.QEI1IF = 0; // clear interrupt
    updateRotationCount(POS1CNT, &(g_rotationCounts[0]));
}

/**
 * Interrupt generated by QE2 roll over/under
 */
void __attribute__((__interrupt__, auto_psv)) _QEI2Interrupt(void) {
    // Interrupt generated by QEI roll over/under
    IFS4bits.QEI2IF = 0; // clear interrupt
    updateRotationCount(POS2CNT, &(g_rotationCounts[1]));
}

/**
 * Update the position counts by reading the current count value and adding the 
 * full counts that are only updated on over-/underflows.
 * New value is written to g_counts.
 * 
 * @param encoderNumber: Either 0 or 1. Indicates which encoder to update.
 */
void updatePositionCount(unsigned char encoderNumber) {
    //disable interrupts to make sure we have consistent data
    _NSTDIS = 1;
    switch (encoderNumber) {
        case 0:
            GET_ENCODER_1(g_counts[encoderNumber]);
            break;

        case 1:
            GET_ENCODER_2(g_counts[encoderNumber]);
            break;
    }
    _NSTDIS = 0;
}

/**
 * Update the delta difference in counts since last time calling this function.
 * This allows to calculate velocities when called with a constant delta time.
 * Caution: requires absolute counts to be up to date. therefore the counts
 * should be updated before calling this function.
 * 
 * @param encoderNumber
 */
void updateDeltaCountsSinceLastCall(unsigned char encoderNumber) {
    static long oldPositions[] = {0, 0};
    long currentPosition;

    currentPosition = g_counts[encoderNumber];
    g_deltaCountsSinceLastCall[encoderNumber] = (currentPosition - oldPositions[encoderNumber]);
    oldPositions[encoderNumber] = currentPosition;
}

/**
 * Update both the absolute encoder position as well as the velocity.
 * 
 * Both values are based on discrete encoder count steps.
 * 
 * After the update, the values can be read from:
 * - g_counts[2]: Absolute counts
 * - g_deltaCountsSinceLastCall[2]: Velocity as delta counts per last call
 * 
 * @param encoderNumber: 0 for left, 1 for right motor encoder
 */
void updateEncoderStates(unsigned char encoderNumber) {
    updatePositionCount(encoderNumber);
    updateDeltaCountsSinceLastCall(encoderNumber);
}

/**
 * Convert counts to rads.
 * 
 * @param counts
 * @return conversion in rads
 */
float convertCountsToRad(long counts) {
    return 3.141592 * 2 * counts / COUNTS_PER_WHEELROTATION;
}

/**
 * Convert counts to wheel rotations.
 * 
 * @param counts
 * @return conversion in wheel rotations
 */
float convertCountsToWheelRots(long counts) {
    return (float) counts / COUNTS_PER_WHEELROTATION;
}