
#include <xc.h>
#include "motorEncoders.h"

long g_rotationCounts[] = {0, 0};
//long currentEncoderPosition;

#include <math.h>

//****************************************************************INITIALISE QEI************************

void initQEI1(unsigned int startPos) {
    QEI1CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI1CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI1CONbits.SWPAB = 0; // Phase A and B not swapped
    QEI1CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI1CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI1CONbits.POSRES = 0; // index does not reset position counter
    QEI1CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI1CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX1CNT = 0xffff;
    POS1CNT = startPos;
    g_rotationCounts[0] = 0;

    IFS3bits.QEI1IF = 0; // clear interrupt flag
    IEC3bits.QEI1IE = 1; // enable interrupt
    IPC14bits.QEI1IP = 5;
}

void initQEI2(unsigned int startPos) {
    QEI2CONbits.QEISIDL = 1; // discontinue module operation in idle mode
    QEI2CONbits.QEIM = 0b111; // Quadrature Encoder Interface enabled (x4mode) with position counter reset by match (MAX1CNT)
    QEI2CONbits.SWPAB = 1; // Phase A and B  swapped
    QEI2CONbits.PCDOUT = 0; // disable position counter direction pin
    QEI2CONbits.TQGATE = 0; // timer gated time acc disabled
    QEI2CONbits.POSRES = 0; // index does not reset position counter
    QEI2CONbits.TQCS = 0; // internal clock source (Tcy))
    QEI2CONbits.UPDN_SRC = 0; // direction of position counter determined using internal logic

    MAX2CNT = 0xffff;
    POS2CNT = startPos;
    g_rotationCounts[1] = 0;

    IFS4bits.QEI2IF = 0; // clear interrupt flag
    IEC4bits.QEI2IE = 1; // enable interrupt
    IPC18bits.QEI2IP = 5;
}

void updateRotationCount(volatile uint16_t posCount, long* globalCount) {
    long change = 0x10000; // POS1CNT goes until 65535 = 0x1111;
    if (posCount < 32768) { // was a roll over
        *globalCount = *globalCount + change; // we had a positive roll-over
    } else { // was a roll under
        *globalCount = *globalCount - change; // we had a negative roll-over
    }
}

void __attribute__((__interrupt__, auto_psv)) _QEI1Interrupt(void) {
    // Interrupt generated by QEI roll over/under
    IFS3bits.QEI1IF = 0; // clear interrupt
    updateRotationCount(POS1CNT, &(g_rotationCounts[0]));
}

void __attribute__((__interrupt__, auto_psv)) _QEI2Interrupt(void) {
    // Interrupt generated by QEI roll over/under
    IFS4bits.QEI2IF = 0; // clear interrupt
    updateRotationCount(POS2CNT, &(g_rotationCounts[1]));
}

long getPositionInCounts(unsigned char encoderNumber) {
    long currentEncoderPosition;

    //disable interrupts to make sure we have consistent data
    _NSTDIS = 1;
    switch (encoderNumber) {
        case 1:
            GET_ENCODER_1(currentEncoderPosition);
            break;

        case 2:
            GET_ENCODER_2(currentEncoderPosition);
            break;
    }
    _NSTDIS = 0;

    return currentEncoderPosition;
}

float getPositionInRad(unsigned char encoderNumber) {
    long currentEncoderPosition = getPositionInCounts(encoderNumber);
    return 3.141592 * 2 * currentEncoderPosition / (16 * 4 * 33);
}

int getVelocityInCountsPerSample(unsigned char encoderNumber) {
    static long oldPositions[] = {0, 0};
    long currentPosition;
    int velocity;

    currentPosition = getPositionInCounts(encoderNumber);
    velocity = (currentPosition - oldPositions[encoderNumber]);
    oldPositions[encoderNumber] = currentPosition;

    return velocity;
}

float getVelocityInRadPerSample(unsigned char encoderNumber) {
    int velocityCounts = getVelocityInCountsPerSample(encoderNumber);
    return 3.141592 * 2 * (float) velocityCounts / (33 * 4 * 16);
}
